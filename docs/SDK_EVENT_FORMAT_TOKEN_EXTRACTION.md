# OpenCode SDK Event Format for Token Extraction

This document provides a comprehensive guide to the OpenCode SDK event format used for token extraction, enabling developers to understand how token usage data is structured and accessed from real-time event streams.

## Table of Contents

1. [Overview](#overview)
2. [Event Types Containing Token Data](#event-types-containing-token-data)
3. [Token Data Structure](#token-data-structure)
4. [Event Extraction Examples](#event-extraction-examples)
5. [SDK Version Compatibility](#sdk-version-compatibility)
6. [Integration Code Examples](#integration-code-examples)
7. [Handling Missing Token Data](#handling-missing-token-data)

---

## Overview

OpenCode SDK provides real-time token usage data through Server-Sent Events (SSE) streams. Token information is embedded in specific event types that occur during AI model interactions. This data enables:

- Real-time token tracking during sessions
- Cost monitoring and budget management
- Usage analytics and reporting
- Performance optimization

### Key Points

- Token data is available only in SDK versions that support usage tracking
- Events are streamed in real-time during active sessions
- Token counts are cumulative across the entire session
- Multiple event types may contain token data for the same interaction

---

## Event Types Containing Token Data

OpenCode SDK emits two primary event types that contain token usage information:

### 1. `message.updated` Events

These events occur when a message is completed or updated, containing comprehensive token information about the entire AI response.

```typescript
interface MessageUpdatedEvent {
  type: 'message.updated';
  properties: {
    info: {
      id: string; // Message ID
      role: 'assistant'; // Message role
      created: number; // Creation timestamp
      tokens?: {
        // Token usage data (optional)
        input?: number; // Input tokens sent to model
        output?: number; // Output tokens generated by model
        reasoning?: number; // Reasoning tokens (for models that support it)
      };
    };
  };
}
```

**When it occurs:**

- After AI completes a response
- When message metadata is updated
- At the end of each turn in the conversation

**Example token values:** `{ input: 1000, output: 500, reasoning: 100 }`

### 2. `message.part.updated` Events (Step Finish)

These events occur when individual parts of a message are completed, particularly useful for multi-step reasoning processes.

```typescript
interface MessagePartUpdatedEvent {
  type: 'message.part.updated';
  properties: {
    part: {
      id: string; // Part ID
      type: 'step-finish'; // Part type containing tokens
      sessionID?: string; // Session identifier
      tokens?: {
        // Token usage data (optional)
        input?: number; // Input tokens for this step
        output?: number; // Output tokens for this step
        reasoning?: number; // Reasoning tokens for this step
      };
    };
  };
}
```

**When it occurs:**

- During multi-step reasoning processes
- When individual processing steps complete
- For complex operations broken into stages

**Example token values:** `{ input: 2000, output: 1000, reasoning: 200 }`

---

## Token Data Structure

The token usage object follows a consistent structure across all event types:

```typescript
interface TokenUsage {
  input?: number; // Tokens sent to the AI model (prompts, context, etc.)
  output?: number; // Tokens generated by the AI model (responses)
  reasoning?: number; // Reasoning tokens (Claude 3.5+ and similar models)
}
```

### Token Types Explained

| Token Type  | Description                                                        | Example Use Case                                     |
| ----------- | ------------------------------------------------------------------ | ---------------------------------------------------- |
| `input`     | Tokens consumed from user input, context, and conversation history | User prompts, code context, file contents            |
| `output`    | Tokens generated in AI responses                                   | Code explanations, generated code, analysis          |
| `reasoning` | Tokens used for internal reasoning (model-dependent)               | Claude 3.5 thinking process, complex problem solving |

### Total Token Calculation

```typescript
// Total tokens used in an event
const totalTokens = (event.input || 0) + (event.output || 0);

// For models that support reasoning
const totalWithReasoning = (event.input || 0) + (event.output || 0) + (event.reasoning || 0);

// Example: { input: 1000, output: 500, reasoning: 100 }
// totalTokens = 1500, totalWithReasoning = 1600
```

---

## Event Extraction Examples

### Basic Token Extraction

```typescript
import { createOpencode } from '@opencode-ai/sdk';

const opencode = await createOpencode({ port: 0 });
const sessionTokens = { input: 0, output: 0, reasoning: 0 };

// Subscribe to real-time events
const events = await opencode.client.event.subscribe();

for await (const event of events.stream) {
  // Extract tokens from message.updated events
  if (event.type === 'message.updated' && event.properties?.info?.tokens) {
    const tokens = event.properties.info.tokens;
    sessionTokens.input += tokens.input || 0;
    sessionTokens.output += tokens.output || 0;
    sessionTokens.reasoning += tokens.reasoning || 0;

    console.log(`Message tokens: +${tokens.input} in, +${tokens.output} out`);
  }

  // Extract tokens from step-finish events
  if (
    event.type === 'message.part.updated' &&
    event.properties?.part?.type === 'step-finish' &&
    event.properties.part.tokens
  ) {
    const tokens = event.properties.part.tokens;
    sessionTokens.input += tokens.input || 0;
    sessionTokens.output += tokens.output || 0;
    sessionTokens.reasoning += tokens.reasoning || 0;

    console.log(`Step tokens: +${tokens.input} in, +${tokens.output} out`);
  }
}
```

### Advanced Token Tracking with Session Association

```typescript
interface SessionTokenTracker {
  [sessionId: string]: {
    input: number;
    output: number;
    reasoning: number;
    lastUpdated: number;
  };
}

const tracker: SessionTokenTracker = {};

for await (const event of events.stream) {
  const sessionId = event.properties?.part?.sessionID || 'default';

  if (!tracker[sessionId]) {
    tracker[sessionId] = { input: 0, output: 0, reasoning: 0, lastUpdated: Date.now() };
  }

  // Process message.updated events
  if (event.type === 'message.updated' && event.properties?.info?.tokens) {
    const tokens = event.properties.info.tokens;
    tracker[sessionId].input += tokens.input || 0;
    tracker[sessionId].output += tokens.output || 0;
    tracker[sessionId].reasoning += tokens.reasoning || 0;
    tracker[sessionId].lastUpdated = Date.now();
  }

  // Process step-finish events
  if (
    event.type === 'message.part.updated' &&
    event.properties?.part?.type === 'step-finish' &&
    event.properties.part.tokens
  ) {
    const tokens = event.properties.part.tokens;
    tracker[sessionId].input += tokens.input || 0;
    tracker[sessionId].output += tokens.output || 0;
    tracker[sessionId].reasoning += tokens.reasoning || 0;
    tracker[sessionId].lastUpdated = Date.now();
  }

  // Log session totals
  const session = tracker[sessionId];
  const total = session.input + session.output + session.reasoning;
  console.log(`Session ${sessionId}: ${total} total tokens`);
}
```

---

## SDK Version Compatibility

Token tracking support varies by OpenCode SDK version. This section provides version detection and compatibility guidance.

### Supported Versions

| SDK Version | Token Tracking Support | Reasoning Tokens |
| ----------- | ---------------------- | ---------------- |
| `>= 1.2.0`  | ‚úÖ Full support        | ‚úÖ Supported     |
| `1.1.x`     | ‚úÖ Basic support       | ‚ùå Not available |
| `< 1.1.0`   | ‚ùå Not available       | ‚ùå Not available |

**Version differences:**

- `>= 1.2.0`: Full token support including reasoning tokens
- `1.1.x`: Basic input/output tokens only
- `< 1.1.0`: No token tracking support available

### Version Detection

This section explains how to implement version detection for token tracking support in your SDK integration. The version detection allows your application to gracefully handle SDK versions that may not support token usage tracking.

```typescript
import { createOpencodeClient } from '@opencode-ai/sdk';

// Version detection function to check token support
async function checkTokenSupport(client: any): Promise<boolean> {
  try {
    // Try to subscribe to events and check for token support
    const events = await client.event.subscribe();

    // Send a test prompt to check event structure
    const testSession = await client.session.create({
      body: { title: 'Token support test' },
    });

    if (!testSession.error) {
      const response = await client.session.prompt({
        path: { id: testSession.data.id },
        body: { parts: [{ type: 'text', text: 'Hello' }] },
      });

      // Check response events for token data
      for await (const event of events.stream) {
        if (event.type === 'message.updated' && event.properties?.info?.tokens) {
          return true; // Token tracking supported
        }
        if (event.type === 'session.idle') {
          break; // Session finished without tokens
        }
      }
    }

    return false;
  } catch (error) {
    console.warn('Token support detection failed:', error);
    return false;
  }
}
```

### Fallback Handling

This section provides fallback handling for SDK versions that don't support token tracking. The fallback handling ensures your application can gracefully degrade when token tracking is not available.

```typescript
// Version detection fallback for unsupported SDK versions
async function createTokenTrackingClient(baseUrl: string) {
  const client = createOpencodeClient({ baseUrl });
  const tokenSupported = await checkTokenSupport(client);

  if (!tokenSupported) {
    console.warn('Token tracking not supported in this SDK version');
    console.warn('Please upgrade to @opencode-ai/sdk >= 1.2.0 for token tracking');
  }

  return { client, tokenSupported };
}
```

````

---

## Integration Code Examples

### Complete Token Tracking Integration

```typescript
import { createOpencode, type Event } from '@opencode-ai/sdk';

class TokenTracker {
  private tokens = { input: 0, output: 0, reasoning: 0 };
  private sessionTokens: Map<string, typeof this.tokens> = new Map();

  constructor(private verbose: boolean = false) {}

  async startTracking(projectPath?: string) {
    const opencode = await createOpencode({
      cwd: projectPath || process.cwd(),
      port: 0,
    });

    const events = await opencode.client.event.subscribe();

    for await (const event of events.stream) {
      this.processEvent(event);
    }

    return opencode;
  }

  private processEvent(event: Event) {
    let extractedTokens: { input?: number; output?: number; reasoning?: number } | null = null;
    const sessionId = this.extractSessionId(event);

    // Extract from message.updated events
    if (event.type === 'message.updated' && event.properties?.info?.tokens) {
      extractedTokens = event.properties.info.tokens;
    }

    // Extract from step-finish events
    if (
      event.type === 'message.part.updated' &&
      event.properties?.part?.type === 'step-finish' &&
      event.properties.part.tokens
    ) {
      extractedTokens = event.properties.part.tokens;
    }

    if (extractedTokens) {
      this.updateTokenCounts(sessionId, extractedTokens);

      if (this.verbose) {
        const input = extractedTokens.input || 0;
        const output = extractedTokens.output || 0;
        const reasoning = extractedTokens.reasoning || 0;

        console.log(
          `[${new Date().toISOString().split('T')[1].slice(0, 8)}] ` +
            `üí∞ Tokens: +${input.toLocaleString()} in, +${output.toLocaleString()} out` +
            (reasoning ? `, +${reasoning.toLocaleString()} reasoning` : ''),
        );
      }
    }
  }

  private extractSessionId(event: Event): string {
    return (event.properties as any)?.part?.sessionID || 'default';
  }

  private updateTokenCounts(
    sessionId: string,
    tokens: { input?: number; output?: number; reasoning?: number },
  ) {
    // Update session-specific tracking
    if (!this.sessionTokens.has(sessionId)) {
      this.sessionTokens.set(sessionId, { input: 0, output: 0, reasoning: 0 });
    }

    const session = this.sessionTokens.get(sessionId)!;
    session.input += tokens.input || 0;
    session.output += tokens.output || 0;
    session.reasoning += tokens.reasoning || 0;

    // Update global totals
    this.tokens.input += tokens.input || 0;
    this.tokens.output += tokens.output || 0;
    this.tokens.reasoning += tokens.reasoning || 0;
  }

  getTotals() {
    return { ...this.tokens };
  }

  getSessionTotals(sessionId: string) {
    return this.sessionTokens.get(sessionId) || { input: 0, output: 0, reasoning: 0 };
  }

  getAllSessions() {
    return Object.fromEntries(this.sessionTokens);
  }
}

// Usage example
async function main() {
  const tracker = new TokenTracker(true); // verbose logging
  await tracker.startTracking();

  // Get token totals at any time
  const totals = tracker.getTotals();
  console.log(`Total tokens: ${totals.input + totals.output + totals.reasoning}`);
}
````

### Integration with Pace CLI

```typescript
// Example integration showing how Pace CLI extracts tokens
export function extractTokensFromEvent(
  event: any,
  sessionTokens: { input: number; output: number; reasoning: number },
) {
  // Track token usage from message.updated events
  if (event.type === 'message.updated' && event.properties?.info) {
    const messageInfo = event.properties.info as {
      tokens?: { input?: number; output?: number; reasoning?: number };
    };
    if (messageInfo.tokens) {
      const messageTokens = messageInfo.tokens || {};
      sessionTokens.input += messageTokens.input ?? 0;
      sessionTokens.output += messageTokens.output ?? 0;
      sessionTokens.reasoning += messageTokens.reasoning ?? 0;
    }
  }

  // Track token usage from step-finish events
  if (event.type === 'message.part.updated' && event.properties?.part?.type === 'step-finish') {
    const stepPart = event.properties.part as {
      tokens?: { input?: number; output?: number; reasoning?: number };
    };
    if (stepPart.tokens) {
      const stepTokens = stepPart.tokens || {};
      sessionTokens.input += stepTokens.input ?? 0;
      sessionTokens.output += stepTokens.output ?? 0;
      sessionTokens.reasoning += stepTokens.reasoning ?? 0;
    }
  }
}
```

---

## Handling Missing Token Data

### Graceful Degradation

```typescript
function safelyExtractTokens(event: any): { input: number; output: number; reasoning: number } {
  const defaultTokens = { input: 0, output: 0, reasoning: 0 };

  try {
    // Handle message.updated events
    if (event.type === 'message.updated' && event.properties?.info?.tokens) {
      const tokens = event.properties.info.tokens;
      return {
        input: Number(tokens.input) || 0,
        output: Number(tokens.output) || 0,
        reasoning: Number(tokens.reasoning) || 0,
      };
    }

    // Handle step-finish events
    if (
      event.type === 'message.part.updated' &&
      event.properties?.part?.type === 'step-finish' &&
      event.properties.part.tokens
    ) {
      const tokens = event.properties.part.tokens;
      return {
        input: Number(tokens.input) || 0,
        output: Number(tokens.output) || 0,
        reasoning: Number(tokens.reasoning) || 0,
      };
    }
  } catch (error) {
    console.warn('Failed to extract tokens from event:', error);
  }

  return defaultTokens;
}
```

### Validation and Error Handling

```typescript
function validateTokenData(tokens: any): boolean {
  if (!tokens || typeof tokens !== 'object') {
    return false;
  }

  const { input, output, reasoning } = tokens;

  // Check that token values are valid numbers
  const isValidNumber = (value: any) =>
    value !== undefined && value !== null && !isNaN(Number(value)) && Number(value) >= 0;

  return (
    (input === undefined || isValidNumber(input)) &&
    (output === undefined || isValidNumber(output)) &&
    (reasoning === undefined || isValidNumber(reasoning))
  );
}

function extractValidatedTokens(
  event: any,
): { input: number; output: number; reasoning: number } | null {
  let tokens: any = null;

  // Extract tokens based on event type
  if (event.type === 'message.updated' && event.properties?.info?.tokens) {
    tokens = event.properties.info.tokens;
  } else if (
    event.type === 'message.part.updated' &&
    event.properties?.part?.type === 'step-finish' &&
    event.properties.part.tokens
  ) {
    tokens = event.properties.part.tokens;
  }

  if (!tokens || !validateTokenData(tokens)) {
    return null;
  }

  return {
    input: Number(tokens.input) || 0,
    output: Number(tokens.output) || 0,
    reasoning: Number(tokens.reasoning) || 0,
  };
}
```

---

## Best Practices

### 1. Always Validate Token Data

```typescript
// Good: Validate before using
const tokens = extractValidatedTokens(event);
if (tokens) {
  sessionTotals.input += tokens.input;
  sessionTotals.output += tokens.output;
}

// Bad: Assume tokens exist and are valid
sessionTotals.input += event.properties.info.tokens.input; // May throw error
```

### 2. Handle Multiple Event Types

```typescript
// Different events may contain overlapping token data
// Accumulate from all sources but avoid double-counting
const processedMessageIds = new Set<string>();

for await (const event of events.stream) {
  if (event.type === 'message.updated' && event.properties?.info?.id) {
    const messageId = event.properties.info.id;

    if (!processedMessageIds.has(messageId)) {
      // First time seeing this message
      processedMessageIds.add(messageId);
      // Extract and add tokens
    }
  }
}
```

### 3. Provide User Feedback

```typescript
if (!tokenSupported) {
  console.log('‚ö†Ô∏è  Token tracking not available');
  console.log('   Upgrade to @opencode-ai/sdk >= 1.2.0 for token usage tracking');
  console.log('   Current costs can be checked in your provider dashboard');
}
```

### 4. Use Reasonable Defaults

```typescript
// When token data is missing, assume 0 rather than failing
const safeTokenCount = (value: any) => {
  const num = Number(value);
  return isNaN(num) || num < 0 ? 0 : num;
};
```

---

## Troubleshooting

### Common Issues

1. **No token data in events**
   - Check SDK version (requires >= 1.2.0 for full support)
   - Verify the AI model supports usage reporting
   - Ensure proper authentication with the provider

2. **Undefined or null token values**
   - Always validate token data before use
   - Use nullish coalescing: `tokens.input ?? 0`

3. **Duplicate token counting**
   - Track processed message IDs to avoid double-counting
   - Understand that `message.updated` and `step-finish` may report overlapping usage

4. **Performance issues with high-frequency events**
   - Batch token updates rather than processing each event individually
   - Consider debouncing token display updates

### Debug Mode

```typescript
function debugEvent(event: any) {
  console.log('Event type:', event.type);
  console.log('Properties:', JSON.stringify(event.properties, null, 2));

  if (event.type === 'message.updated') {
    console.log('Has tokens:', !!event.properties?.info?.tokens);
    if (event.properties?.info?.tokens) {
      console.log('Tokens:', event.properties.info.tokens);
    }
  }

  if (event.type === 'message.part.updated') {
    console.log('Part type:', event.properties?.part?.type);
    console.log('Has tokens:', !!event.properties?.part?.tokens);
    if (event.properties?.part?.tokens) {
      console.log('Tokens:', event.properties.part.tokens);
    }
  }
}
```

---

## References

- [OpenCode SDK Documentation](./SDK_PROGRAMMATIC_USAGE.md)
- [Token Usage Examples](./token-usage-examples.md)
- [Troubleshooting Guide](./troubleshooting.md)
- [Pace Token Tracking Implementation](../cli.ts) - See `extractTokensFromEvent` function
